package parser;

import java_cup.runtime.*;
import ast.base.*;
import ast.declaration.*;
import ast.expression.*;
import ast.function.*;
import ast.statement.*;
import ast.type.*;
import java.util.List;
import java.util.ArrayList;

terminal VAR, TYPE, INTEGER, BOOLEAN, REAL, ARRAY, RECORD, TRUE, FALSE, IS;
terminal IF, THEN, ELSE, END, FOR, IN, REVERSE, LOOP, WHILE, ROUTINE, RETURN;
terminal PLUS, MINUS, MUL, DIV, MOD, ASSIGN, EQ, NE, GT, LT, GE, LE;
terminal AND, OR, XOR, NOT;
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, COMMA, DOT, RANGE, COLON, SEMICOLON;
terminal String IDENTIFIER;
terminal Integer INTEGERNUM;
terminal Double REALNUM;

non terminal Program;
non terminal ProgramUnit;
non terminal DeclarationList;
non terminal Declaration;
non terminal VariableDeclaration;
non terminal TypeDeclaration;
non terminal Statement;
non terminal StatementList;
non terminal Expression;
non terminal Type;
non terminal Function;
non terminal ParamList;
non terminal ParamListNonEmpty;
non terminal ReturnTypeOpt;
non terminal NestedRecordAccess;
non terminal ProgramUnits;

/* Define precedences */
precedence left OR, AND, XOR;
precedence left EQ, NE, LT, GT, LE, GE;
precedence left PLUS, MINUS;
precedence left MUL, DIV, MOD;
precedence right NOT;


/* Grammar rules */
Program ::= ProgramUnits:units {:
                RESULT = new Program((List<ProgramUnit>) units);
            :};

ProgramUnits ::= ProgramUnits:units ProgramUnit:unit {:
                    ((List<ProgramUnit>) units).add((ProgramUnit) unit);
                    RESULT = units;
                :}
               | /* empty */ {: RESULT = new ArrayList<ProgramUnit>(); :};

ProgramUnit ::= Declaration:decl {: RESULT = decl; :}
              | Statement:stmt {: RESULT = stmt; :}
              | Function:function {: RESULT = function; :};

DeclarationList ::= Declaration:decl DeclarationList:list
                 {:
                    List<Declaration> decls = new ArrayList<>();
                    decls.add((Declaration) decl);
                    decls.addAll((List<Declaration>) list);
                    RESULT = decls;
                  :}
                 | /* empty */ {: RESULT = new ArrayList<Declaration>(); :};

Declaration ::= VariableDeclaration:varDecl {: RESULT = varDecl; :}
              | TypeDeclaration:typeDecl {: RESULT = typeDecl; :};

VariableDeclaration ::= VAR IDENTIFIER:id COLON Type:type SEMICOLON {: RESULT = new VariableDeclaration((String) id, (Type) type); :}
                      | VAR IDENTIFIER:id COLON Type:type IS Expression:expr SEMICOLON {: RESULT = new VariableDeclaration((String) id, (Type) type, (Expression) expr); :}
                      | VAR IDENTIFIER:id IS Expression:expr SEMICOLON {: RESULT = new VariableDeclaration((String) id, (Expression) expr); :};

TypeDeclaration ::= TYPE IDENTIFIER:id IS Type:type SEMICOLON {: RESULT = new TypeDeclaration((String) id, (Type) type); :};

Type ::= INTEGER {: RESULT = new IntegerType(); :}
       | BOOLEAN {: RESULT = new BooleanType(); :}
       | REAL {: RESULT = new RealType(); :}
       | IDENTIFIER:id {: RESULT = new IdentifierType((String) id); :}
       | ARRAY LBRACKET INTEGERNUM:size RBRACKET Type:elemType {: new ArrayType((Integer) size, (Type) elemType); :}
       | RECORD DeclarationList:fields END {: RESULT = new RecordType((List<Declaration>) fields); :};

StatementList ::= Statement:statement StatementList:list
                {:
                    List<Statement> statements = new ArrayList<>();
                    statements.add((Statement) statement);
                    statements.addAll((List<Statement>) list);
                    RESULT = statements;
                :}
                | /* empty */ {: RESULT = new ArrayList<Statement>(); :};

Statement ::= IDENTIFIER:id ASSIGN Expression:expr SEMICOLON
            {: RESULT = new AssignmentStatement((String) id, (Expression) expr); :}
            | IDENTIFIER:id LBRACKET Expression:index RBRACKET ASSIGN Expression:expr SEMICOLON
            {: RESULT = new AssignmentStatement((String) id, (Expression) index, (Expression) expr); :}
            | NestedRecordAccess:recordField DOT IDENTIFIER:id ASSIGN Expression:expr SEMICOLON
            {: RESULT = new AssignmentStatement((NestedRecordAccess) recordField, (String) id, (Expression) expr); :}
            | IDENTIFIER:id LPAREN ParamList:paramList RPAREN SEMICOLON
            {: RESULT = new CallStatement((String) id, (List<Expression>) paramList); :}
            | IF Expression:cond THEN DeclarationList:decls StatementList:stmts END SEMICOLON
            {: RESULT = new IfStatement((Expression) cond, (List<Declaration>) decls, (List<Statement>) stmts); :}
            | IF Expression:cond THEN DeclarationList:declsThen StatementList:stmtsThen ELSE DeclarationList:declsElse StatementList:stmtsElse END SEMICOLON
            {: RESULT = new IfStatement((Expression) cond, (List<Declaration>) declsThen, (List<Declaration>) declsElse, (List<Statement>) stmtsThen, (List<Statement>) stmtsElse); :}
            | WHILE Expression:cond LOOP DeclarationList:decls StatementList:stmts END SEMICOLON
            {: RESULT = new WhileStatement((Expression) cond, (List<Declaration>) decls, (List<Statement>) stmts); :}
            | FOR IDENTIFIER:id IN Expression:start RANGE Expression:end LOOP DeclarationList:decls StatementList:stmts END SEMICOLON
            {:  RESULT = new ForStatement((String) id, (Expression) start, (Expression) end, false, (List<Declaration>) decls, (List<Statement>) stmts); :}
            | FOR IDENTIFIER:id IN REVERSE Expression:start RANGE Expression:end LOOP DeclarationList:decls StatementList:stmts END SEMICOLON
            {:  RESULT = new ForStatement((String) id, (Expression) start, (Expression) end, true, (List<Declaration>) decls, (List<Statement>) stmts); :}
            | RETURN Expression:expr SEMICOLON
            {: RESULT = new ReturnStatement((Expression) expr); :};

Expression ::= Expression PLUS Expression
             | Expression MINUS Expression
             | Expression MUL Expression
             | Expression DIV Expression
             | Expression MOD Expression
             | Expression EQ Expression
             | Expression NE Expression
             | Expression GT Expression
             | Expression LT Expression
             | Expression GE Expression
             | Expression LE Expression
             | Expression AND Expression
             | Expression OR Expression
             | Expression XOR Expression
             | NOT Expression
             | TRUE
             | FALSE
             | INTEGERNUM
             | REALNUM
             | IDENTIFIER LBRACKET Expression RBRACKET
             | IDENTIFIER LPAREN ParamList RPAREN
             | LPAREN Expression RPAREN
             | NestedRecordAccess;

NestedRecordAccess ::= IDENTIFIER
             | NestedRecordAccess DOT IDENTIFIER;

Function ::= ROUTINE IDENTIFIER:id LPAREN ParamList RPAREN ReturnTypeOpt IS DeclarationList StatementList END SEMICOLON
            {: System.out.println("Function definition: " + id); :};

ParamList ::= /* empty */
            | ParamListNonEmpty;

ParamListNonEmpty ::= Expression
                    | ParamListNonEmpty COMMA Expression
                    | IDENTIFIER COLON Type
                    | ParamListNonEmpty COMMA IDENTIFIER COLON Type;

ReturnTypeOpt ::= COLON Type
                | /* empty */;
